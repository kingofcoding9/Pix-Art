<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Omni-Pix Studio</title>
    <!-- Browser Tab Icon -->
    <link rel="icon" type="image/jpeg" href="Omni-Science Logo.jpg">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        space: {
                            900: '#050b14', // Deepest background
                            800: '#0f172a', // Panels
                            700: '#1e293b', // Borders
                        },
                        tech: {
                            400: '#22d3ee', // Cyan accent
                            500: '#06b6d4',
                            glow: 'rgba(34, 211, 238, 0.5)'
                        }
                    },
                    animation: {
                        'surge': 'surge 8s linear infinite',
                        'twinkle': 'twinkle 4s ease-in-out infinite',
                    },
                }
            }
        }
    </script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050b14;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* Prevent browser zooming/panning globally */
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(15, 23, 42, 0.3); }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #22d3ee; }
        .range-sm::-webkit-slider-thumb { width: 12px; height: 12px; background: #22d3ee; }
        
        /* Glass Panels */
        .glass-panel {
            background: rgba(15, 23, 42, 0.9); 
            backdrop-filter: blur(12px);
            border: 1px solid rgba(34, 211, 238, 0.15);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
        }

        .tab-active {
            background: rgba(6, 182, 212, 0.2);
            border-bottom: 2px solid #22d3ee;
            color: #22d3ee;
        }
        .tab-inactive {
            color: #64748b;
        }
        .tab-inactive:hover {
            color: #94a3b8;
            background: rgba(15, 23, 42, 0.4);
        }
        
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="text-slate-300">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Space Background Component ---
        const SpaceBackground = () => {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                let width, height, stars = [];
                
                const resize = () => {
                    width = canvas.width = window.innerWidth;
                    height = canvas.height = window.innerHeight;
                    initStars();
                };
                
                const initStars = () => {
                    stars = [];
                    const count = Math.floor((width * height) / 8000); 
                    for(let i=0; i<count; i++) {
                        stars.push({
                            x: Math.random() * width,
                            y: Math.random() * height,
                            size: Math.random() * 1.5,
                            speed: Math.random() * 0.3 + 0.1,
                            opacity: Math.random(),
                            twinkleSpeed: Math.random() * 0.03
                        });
                    }
                };
                
                let frameId;
                const animate = () => {
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#FFF';
                    
                    stars.forEach(star => {
                        star.y += star.speed;
                        if(star.y > height) star.y = 0;
                        star.opacity += star.twinkleSpeed;
                        if(star.opacity > 1 || star.opacity < 0.2) star.twinkleSpeed *= -1;
                        
                        ctx.globalAlpha = star.opacity;
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.size, 0, Math.PI*2);
                        ctx.fill();
                    });
                    
                    frameId = requestAnimationFrame(animate);
                };
                
                window.addEventListener('resize', resize);
                resize();
                animate();
                return () => { window.removeEventListener('resize', resize); cancelAnimationFrame(frameId); }
            }, []);
            
            return (
                <div className="fixed inset-0 pointer-events-none z-0 overflow-hidden bg-gradient-to-b from-[#020408] via-[#050b14] to-[#020408]">
                    <canvas ref={canvasRef} className="absolute inset-0" />
                </div>
            );
        };

        // --- Icons ---
        const Icons = {
            Pencil: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>,
            Eraser: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg>,
            Bucket: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z"/><path d="m5 2 5 5"/><path d="M2 13h15"/><path d="M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z"/></svg>,
            BucketAll: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z"/><path d="m5 2 5 5"/><path d="M2 13h15"/><path d="M2 17h20"/></svg>,
            EyeDropper: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m2 22 1-1h3l9-9"/><path d="M3 21v-3l9-9"/><path d="m15 6 3.4-3.4a2.1 2.1 0 1 1 3 5L18 9l.9.9"/><path d="m10 14 1.1 1.1a2.1 2.1 0 1 1-2.9 2.9l-1.1-1.1"/><path d="m15 6-3 3"/><path d="m15 9 3 3"/></svg>,
            Line: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="2" y1="22" x2="22" y2="2"/></svg>,
            Rect: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/></svg>,
            Circle: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/></svg>,
            Dither: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="2" width="4" height="4"/><rect x="10" y="2" width="4" height="4"/><rect x="18" y="2" width="4" height="4"/><rect x="6" y="6" width="4" height="4"/><rect x="14" y="6" width="4" height="4"/><rect x="2" y="10" width="4" height="4"/><rect x="10" y="10" width="4" height="4"/><rect x="18" y="10" width="4" height="4"/><rect x="6" y="14" width="4" height="4"/><rect x="14" y="14" width="4" height="4"/><rect x="2" y="18" width="4" height="4"/><rect x="10" y="18" width="4" height="4"/><rect x="18" y="18" width="4" height="4"/></svg>,
            Lighten: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>,
            MovePixels: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M5 9l-3 3 3 3M9 5l3-3 3 3M19 9l3 3-3 3M9 19l3 3 3-3M2 12h20M12 2v20"/><rect x="8" y="8" width="8" height="8" rx="1"/></svg>,
            Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Trash: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>,
            Eye: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>,
            EyeOff: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>,
            Play: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
            Pause: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>,
            Copy: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>,
            Download: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>,
            Upload: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>,
            Close: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>,
            Center: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>,
            Undo: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 0 0 0-6 2.3L3 13"/></svg>,
            Redo: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"/></svg>,
            Folder: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 2H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"/></svg>,
            File: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><polyline points="13 2 13 9 20 9"/></svg>,
            Image: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>,
            ChevronUp: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m18 15-6-6-6 6"/></svg>,
            ChevronDown: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m6 9 6 6 6-6"/></svg>,
            Gear: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.1a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>,
            Resize: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M15 3h6v6"/><path d="M14 10L21 3"/><path d="M9 21H3v-6"/><path d="M10 14L3 21"/></svg>
        };

        const rgbToHex = (r, g, b) => "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        const hexToRgb = (hex) => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : { r: 0, g: 0, b: 0 };
        };

        const adjustBrightness = (hex, amount) => {
            let { r, g, b } = hexToRgb(hex);
            r = Math.min(255, Math.max(0, r + amount));
            g = Math.min(255, Math.max(0, g + amount));
            b = Math.min(255, Math.max(0, b + amount));
            return rgbToHex(r, g, b);
        };

        const getColorDistance = (hex1, hex2) => {
            const c1 = hexToRgb(hex1);
            const c2 = hexToRgb(hex2);
            return Math.sqrt(Math.pow(c1.r - c2.r, 2) + Math.pow(c1.g - c2.g, 2) + Math.pow(c1.b - c2.b, 2));
        };

        const Modal = ({ isOpen, title, children, onClose, onConfirm, showConfirm = true, confirmText = 'OK' }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/70 backdrop-blur-sm">
                    <div className="bg-space-800 rounded-xl shadow-[0_0_20px_rgba(34,211,238,0.2)] border border-tech-glow w-full max-w-sm p-6 transform transition-all m-4">
                        <div className="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                            <h3 className="text-lg font-bold text-tech-400 tracking-wider uppercase">{title}</h3>
                            <button onClick={onClose} className="text-gray-400 hover:text-white"><Icons.Close /></button>
                        </div>
                        <div className="mb-6 text-gray-300">{children}</div>
                        <div className="flex justify-end gap-2">
                            <button onClick={onClose} className="px-4 py-2 rounded bg-space-700 hover:bg-gray-600 text-sm font-medium border border-gray-600">Cancel</button>
                            {showConfirm && <button onClick={onConfirm} className="px-4 py-2 rounded bg-tech-500 hover:bg-tech-400 text-white text-sm font-bold shadow-[0_0_10px_rgba(34,211,238,0.4)]">{confirmText}</button>}
                        </div>
                    </div>
                </div>
            );
        };

        function PixelArtStudio() {
            // --- Helper to create a fresh project ---
            const createNewProjectData = (id, name = 'Untitled', size = 32) => ({
                id,
                name,
                gridSize: size,
                frames: [{ id: 'f1', layers: [{ id: 'l1', name: 'Layer 1', visible: true, opacity: 100, pixels: Array(size*size).fill(null) }] }],
                fps: 8,
                history: [],
                historyIndex: -1
            });

            // --- Initialization & State ---
            const [projects, setProjects] = useState(() => {
                const saved = localStorage.getItem('pixStudioProjects');
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed) && parsed.length > 0) return parsed;
                    } catch(e) {}
                }
                const initial = createNewProjectData('p' + Date.now(), 'Project 1');
                initial.history = [JSON.parse(JSON.stringify(initial.frames))];
                initial.historyIndex = 0;
                return [initial];
            });

            const [activeProjectId, setActiveProjectId] = useState(() => {
                const saved = localStorage.getItem('pixStudioActiveId');
                return saved || (projects[0] ? projects[0].id : null);
            });

            // Derived state for current project
            const currentProjectIndex = projects.findIndex(p => p.id === activeProjectId);
            const currentProject = projects[currentProjectIndex] || projects[0];
            
            // Local state for UI
            const [currentFrameIndex, setCurrentFrameIndex] = useState(0);
            const [activeLayerId, setActiveLayerId] = useState('l1');
            
            const [tool, setTool] = useState('pencil');
            const [color, setColor] = useState('#00eaff');
            const [brushSize, setBrushSize] = useState(1);
            const [toolOpacity, setToolOpacity] = useState(100);
            const [mirrorMode, setMirrorMode] = useState('none');
            const [recentColors, setRecentColors] = useState(['#00eaff', '#ff00ff', '#ffffff', '#000000', '#2a2a2a']);
            
            const [isPlaying, setIsPlaying] = useState(false);
            const [onionSkin, setOnionSkin] = useState(false);
            const [zoom, setZoom] = useState(0.8);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [showGrid, setShowGrid] = useState(true);
            const [activeTab, setActiveTab] = useState('layers');
            const [hoverPos, setHoverPos] = useState(null);
            const [tooltip, setTooltip] = useState(null);
            
            // Mobile UI State
            const [isMobilePanelOpen, setIsMobilePanelOpen] = useState(false);
            const [isMobileToolOptionsOpen, setIsMobileToolOptionsOpen] = useState(false);
            const [panMode, setPanMode] = useState(false); // For mobile manual panning
            const [darkenMode, setDarkenMode] = useState(false); // For lighten/darken tool on mobile
            
            const [modalConfig, setModalConfig] = useState({ isOpen: false, type: '', data: null });
            const [inputValue, setInputValue] = useState('');
            const [inputNumberValue, setInputNumberValue] = useState(32);
            
            // Palette State
            const [editingPaletteId, setEditingPaletteId] = useState(null);
            const [paletteConfig, setPaletteConfig] = useState({ img: null, count: 8, variety: false });
            const [newSwatchColor, setNewSwatchColor] = useState('#ffffff');

            const [floatingSelection, setFloatingSelection] = useState(null); 
            const [library, setLibrary] = useState(() => {
                const saved = localStorage.getItem('pixelArtPaletteLibrary');
                return saved ? JSON.parse(saved) : [{ id: 'default', name: 'Cosmic Colors', palettes: [] }];
            });
            const [currentFolderId, setCurrentFolderId] = useState('default');

            // Refs
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const paletteInputRef = useRef(null);
            const imageImportRef = useRef(null);
            const paletteImageImportRef = useRef(null);
            const isDrawing = useRef(false);
            const isPanning = useRef(false);
            const lastPos = useRef(null);
            const playInterval = useRef(null);
            const startDrawPos = useRef(null); 

            // Convenience getters
            const frames = currentProject.frames;
            const gridSize = currentProject.gridSize;
            const currentFrame = frames[currentFrameIndex] || frames[0];
            const activeLayer = currentFrame.layers.find(l => l.id === activeLayerId) || currentFrame.layers[0];

            // Tools Definition
            const TOOLS = [
                { id: 'pencil', icon: Icons.Pencil, label: 'Pencil', binding: 'B', desc: 'Draw standard pixels' },
                { id: 'eraser', icon: Icons.Eraser, label: 'Eraser', binding: 'E', desc: 'Clear pixels from layer' },
                { id: 'dropper', icon: Icons.EyeDropper, label: 'Picker', binding: 'I', desc: 'Click to sample color' },
                { id: 'bucket', icon: Icons.Bucket, label: 'Fill', binding: 'F', desc: 'Fill connected area' },
                { id: 'bucket_all', icon: Icons.BucketAll, label: 'Paint All', binding: 'A', desc: 'Replace color on whole layer' },
                { id: 'move_pixels', icon: Icons.MovePixels, label: 'Move', binding: 'M', desc: 'Move contents of layer' },
                { id: 'line', icon: Icons.Line, label: 'Line', binding: 'L', desc: 'Draw straight lines' },
                { id: 'rect', icon: Icons.Rect, label: 'Rect', binding: 'R', desc: 'Draw outlined rectangles' },
                { id: 'circle', icon: Icons.Circle, label: 'Circle', binding: 'C', desc: 'Draw outlined circles' },
                { id: 'dither', icon: Icons.Dither, label: 'Dither', binding: 'D', desc: 'Checkered pattern brush' },
                { id: 'lighten', icon: Icons.Lighten, label: 'Light/Dark', binding: 'H', desc: 'Shift: Darken' },
            ];

            const currentToolDef = TOOLS.find(t => t.id === tool);

            // --- Effects ---
            useEffect(() => {
                localStorage.setItem('pixStudioProjects', JSON.stringify(projects));
                localStorage.setItem('pixStudioActiveId', activeProjectId);
            }, [projects, activeProjectId]);

            useEffect(() => localStorage.setItem('pixelArtPaletteLibrary', JSON.stringify(library)), [library]);

            // Ensure active layer exists when frame changes
            useEffect(() => {
                if (currentFrame && !currentFrame.layers.find(l => l.id === activeLayerId)) {
                    setActiveLayerId(currentFrame.layers[0].id);
                }
            }, [currentFrameIndex, frames]);

            // Initialize history for a new project if empty
            useEffect(() => {
                if (currentProject.history.length === 0) {
                     updateProject(currentProject.id, {
                         history: [JSON.parse(JSON.stringify(currentProject.frames))],
                         historyIndex: 0
                     });
                }
            }, [activeProjectId]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    if (e.ctrlKey) {
                        if (e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
                        if (e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
                        return;
                    }
                    switch(e.key.toLowerCase()) {
                        case 'b': setTool('pencil'); break;
                        case 'e': setTool('eraser'); break;
                        case 'f': setTool('bucket'); break;
                        case 'a': setTool('bucket_all'); break;
                        case 'm': setTool('move_pixels'); break;
                        case 'l': setTool('line'); break;
                        case 'r': setTool('rect'); break;
                        case 'c': setTool('circle'); break;
                        case 'd': setTool('dither'); break;
                        case 'i': setTool('dropper'); break;
                        case 'h': setTool('lighten'); break;
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [projects, activeProjectId]);

            useEffect(() => {
                if (isPlaying) {
                    playInterval.current = setInterval(() => setCurrentFrameIndex(prev => (prev + 1) % frames.length), 1000 / currentProject.fps);
                } else clearInterval(playInterval.current);
                return () => clearInterval(playInterval.current);
            }, [isPlaying, currentProject.fps, frames.length]);

            // --- Auto-Fit Canvas to Screen ---
            const fitToScreen = useCallback(() => {
                if (!containerRef.current) return;
                const { width, height } = containerRef.current.getBoundingClientRect();
                if (width === 0 || height === 0) return;

                const padding = 40; // Space for margins
                const availableW = width - padding;
                const availableH = height - padding;
                const baseSize = 512; // Base logical size of canvas wrapper
                
                // Calculate zoom needed to fit the baseSize into available space
                const scaleW = availableW / baseSize;
                const scaleH = availableH / baseSize;
                
                let newZoom = Math.min(scaleW, scaleH);
                if (window.innerWidth >= 768) {
                    newZoom = Math.min(newZoom, 1);
                } else {
                     newZoom = Math.max(newZoom, 0.1); 
                }

                setZoom(newZoom);
                const visualW = 512 * newZoom;
                const visualH = 512 * newZoom;
                const offsetX = (width - visualW) / 2;
                const offsetY = (height - visualH) / 2;
                setPan({x: offsetX, y: offsetY});
            }, []);

            useEffect(() => {
                if (!containerRef.current) return;
                const resizeObserver = new ResizeObserver(() => fitToScreen());
                resizeObserver.observe(containerRef.current);
                return () => resizeObserver.disconnect();
            }, [fitToScreen]);

            useEffect(() => fitToScreen(), [isMobilePanelOpen, fitToScreen]);


            // --- Core Helper to Update Project State ---
            const updateProject = (pid, changes) => {
                setProjects(prev => prev.map(p => {
                    if (p.id !== pid) return p;
                    return { ...p, ...changes };
                }));
            };

            const saveHistory = (newFrames) => {
                const deepCopy = JSON.parse(JSON.stringify(newFrames));
                const newHistory = currentProject.history.slice(0, currentProject.historyIndex + 1);
                newHistory.push(deepCopy);
                if (newHistory.length > 20) newHistory.shift();
                
                updateProject(activeProjectId, {
                    frames: deepCopy,
                    history: newHistory,
                    historyIndex: newHistory.length - 1
                });
            };

            const undo = () => {
                if (currentProject.historyIndex > 0) {
                    const idx = currentProject.historyIndex - 1;
                    updateProject(activeProjectId, {
                        historyIndex: idx,
                        frames: JSON.parse(JSON.stringify(currentProject.history[idx]))
                    });
                }
            };

            const redo = () => {
                if (currentProject.historyIndex < currentProject.history.length - 1) {
                    const idx = currentProject.historyIndex + 1;
                    updateProject(activeProjectId, {
                        historyIndex: idx,
                        frames: JSON.parse(JSON.stringify(currentProject.history[idx]))
                    });
                }
            };

            // --- Rendering ---
            const renderCanvas = useCallback(() => {
                const canvas = canvasRef.current;
                if(!canvas) return;
                const ctx = canvas.getContext('2d');
                const pSize = canvas.width / gridSize;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Checkerboard
                for(let y=0; y<gridSize; y++) {
                    for(let x=0; x<gridSize; x++) {
                        ctx.fillStyle = (x+y)%2 === 0 ? '#1e293b' : '#334155';
                        ctx.fillRect(x*pSize, y*pSize, pSize, pSize);
                    }
                }

                // Onion Skin
                if (onionSkin && currentFrameIndex > 0 && !isPlaying) {
                    const prevFrame = frames[currentFrameIndex - 1];
                    ctx.globalAlpha = 0.5; 
                    prevFrame.layers.slice().reverse().forEach(layer => {
                        if (!layer.visible) return;
                        layer.pixels.forEach((col, i) => {
                            if(col) {
                                ctx.fillStyle = col;
                                ctx.fillRect((i%gridSize)*pSize, Math.floor(i/gridSize)*pSize, pSize, pSize);
                            }
                        });
                    });
                    ctx.globalAlpha = 1.0;
                }

                // Layers
                if (currentFrame && currentFrame.layers) {
                    currentFrame.layers.slice().reverse().forEach(layer => {
                        if (!layer.visible) return;
                        ctx.globalAlpha = layer.opacity / 100;
                        layer.pixels.forEach((col, i) => {
                            if (col) {
                                ctx.fillStyle = col;
                                ctx.fillRect((i % gridSize) * pSize, Math.floor(i / gridSize) * pSize, pSize, pSize);
                            }
                        });
                    });
                }
                ctx.globalAlpha = 1.0;

                // Tool Previews
                if (hoverPos && !isPanning.current && !isPlaying && !panMode) {
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = getColorWithOpacity();
                    
                    const drawPreviewPixel = (x, y) => {
                        if(x>=0 && x<gridSize && y>=0 && y<gridSize) ctx.fillRect(x*pSize, y*pSize, pSize, pSize);
                    };

                    if (isDrawing.current && startDrawPos.current && ['line', 'rect', 'circle'].includes(tool)) {
                        const x0 = startDrawPos.current.x, y0 = startDrawPos.current.y;
                        const x = hoverPos.x, y = hoverPos.y;
                        if (tool === 'line') {
                            getLinePoints(x0, y0, x, y).forEach(pt => drawPreviewPixel(pt.x, pt.y));
                        } else if (tool === 'rect') {
                            const rx = Math.min(x0, x), ry = Math.min(y0, y);
                            const rw = Math.abs(x - x0) + 1, rh = Math.abs(y - y0) + 1;
                            for(let i=rx; i<rx+rw; i++) { drawPreviewPixel(i, ry); drawPreviewPixel(i, ry+rh-1); }
                            for(let i=ry; i<ry+rh; i++) { drawPreviewPixel(rx, i); drawPreviewPixel(rx+rw-1, i); }
                        } else if (tool === 'circle') {
                             const r = Math.floor(Math.sqrt(Math.pow(x-x0,2) + Math.pow(y-y0,2)));
                             for(let cy=y0-r; cy<=y0+r; cy++) {
                                 for(let cx=x0-r; cx<=x0+r; cx++) {
                                     const dist = Math.sqrt(Math.pow(cx-x0,2) + Math.pow(cy-y0,2));
                                     if (dist >= r - 0.5 && dist <= r + 0.5) drawPreviewPixel(cx, cy);
                                 }
                             }
                        }
                    } else if (tool === 'pencil' || tool === 'eraser' || tool === 'lighten' || tool === 'dither' || tool === 'bucket' || tool === 'bucket_all') {
                        for(let oy = -Math.floor(brushSize/2); oy <= Math.floor((brushSize-1)/2); oy++) {
                            for(let ox = -Math.floor(brushSize/2); ox <= Math.floor((brushSize-1)/2); ox++) {
                                const px = hoverPos.x + ox, py = hoverPos.y + oy;
                                if (tool === 'dither' && (px + py) % 2 !== 0) continue;
                                drawPreviewPixel(px, py);
                            }
                        }
                    } else if (tool === 'line' || tool === 'rect' || tool === 'circle') {
                         drawPreviewPixel(hoverPos.x, hoverPos.y);
                    }
                    ctx.globalAlpha = 1.0;
                }

                // Selection
                if (floatingSelection) {
                    floatingSelection.pixels.forEach(p => {
                        const drawX = p.x + floatingSelection.offsetX;
                        const drawY = p.y + floatingSelection.offsetY;
                        if (drawX >= 0 && drawX < gridSize && drawY >= 0 && drawY < gridSize) {
                            ctx.fillStyle = p.color;
                            ctx.fillRect(drawX * pSize, drawY * pSize, pSize, pSize);
                            ctx.strokeStyle = '#22d3ee';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(drawX * pSize, drawY * pSize, pSize, pSize);
                        }
                    });
                }

                // Grid Lines
                if (showGrid && zoom > 4) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                    ctx.lineWidth = 1/zoom;
                    ctx.beginPath();
                    for(let i=0; i<=gridSize; i++) {
                        ctx.moveTo(i*pSize, 0); ctx.lineTo(i*pSize, canvas.height);
                        ctx.moveTo(0, i*pSize); ctx.lineTo(canvas.width, i*pSize);
                    }
                    ctx.stroke();
                }

            }, [frames, currentFrame, currentFrameIndex, gridSize, zoom, showGrid, onionSkin, isPlaying, floatingSelection, hoverPos, tool, brushSize, color, toolOpacity, startDrawPos, panMode]);

            useEffect(() => { requestAnimationFrame(renderCanvas); }, [renderCanvas]);

            // --- Logic Helpers ---
            const addRecentColor = (c) => {
                setRecentColors(prev => {
                    const normalized = c.toUpperCase();
                    if (prev.includes(normalized)) return [normalized, ...prev.filter(x => x !== normalized)];
                    return [normalized, ...prev].slice(0, 16);
                });
            };

            const resetCanvas = (size) => {
                const newFrames = [{ id: 'f1', layers: [{ id: 'l1', name: 'Layer 1', visible: true, opacity: 100, pixels: Array(size*size).fill(null) }] }];
                updateProject(activeProjectId, {
                    gridSize: size,
                    frames: newFrames,
                    history: [JSON.parse(JSON.stringify(newFrames))],
                    historyIndex: 0
                });
                setCurrentFrameIndex(0);
                setActiveLayerId('l1');
                fitToScreen(); // Fit on reset
            };

            const openModal = (type, data = null) => { 
                setInputValue(''); 
                if (type === 'newProject') setInputNumberValue(32);
                if (type === 'resize') setInputNumberValue(gridSize);
                if (type === 'addSwatch') setNewSwatchColor(color);
                setModalConfig({ isOpen: true, type, data }); 
            };
            const closeModal = () => setModalConfig({ ...modalConfig, isOpen: false });

            const handleModalConfirm = () => {
                if (modalConfig.type === 'resize') {
                    const size = inputNumberValue;
                    if(size && size > 0) resetCanvas(size);
                } else if (modalConfig.type === 'confirm-resize') {
                     resetCanvas(modalConfig.data);
                } else if (modalConfig.type === 'newProject') {
                    const size = inputNumberValue;
                    if(size && size > 0 && inputValue) {
                        const newId = 'p' + Date.now();
                        const newProj = createNewProjectData(newId, inputValue, size);
                        setProjects([...projects, newProj]);
                        setActiveProjectId(newId);
                        setZoom(1); setPan({x:0,y:0}); setCurrentFrameIndex(0);
                    }
                } else if (modalConfig.type === 'clear') {
                    const newFrames = JSON.parse(JSON.stringify(frames));
                    const f = newFrames[currentFrameIndex];
                    f.layers = f.layers.map(l => l.id === activeLayerId ? { ...l, pixels: Array(gridSize*gridSize).fill(null) } : l);
                    saveHistory(newFrames);
                } else if (modalConfig.type === 'newFolder' && inputValue) {
                    setLibrary(prev => [...prev, { id: Date.now().toString(), name: inputValue, palettes: [] }]);
                } else if (modalConfig.type === 'newPalette' && inputValue) {
                    const colors = modalConfig.data || ['#00eaff', '#ff00ff']; // Use passed data or default
                    setLibrary(prev => prev.map(folder => {
                        if(folder.id === currentFolderId) {
                            return { ...folder, palettes: [...folder.palettes, { id: Date.now(), name: inputValue, colors }] };
                        }
                        return folder;
                    }));
                } else if (modalConfig.type === 'addSwatch') {
                    // Modal handles adding either current color or newSwatchColor
                    if (modalConfig.data && modalConfig.data.paletteId) {
                         addColorToPalette(modalConfig.data.paletteId, newSwatchColor);
                    }
                } else if (modalConfig.type === 'paletteImportOptions') {
                    // Logic to extract prevalent colors based on config
                    const { img, count, variety } = paletteConfig;
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    // Downscale for performance
                    const scale = Math.min(1, 256 / Math.max(img.width, img.height));
                    canvas.width = img.width * scale;
                    canvas.height = img.height * scale;
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                    const colorCounts = {};
                    
                    for(let i=0; i<data.length; i+=4) {
                        // Strict transparency check: Skip if alpha is low (e.g., < 20 out of 255)
                        if(data[i+3] > 20) { 
                            const hex = rgbToHex(data[i], data[i+1], data[i+2]);
                            colorCounts[hex] = (colorCounts[hex] || 0) + 1;
                        }
                    }
                    
                    // Sort by frequency
                    let sortedColors = Object.entries(colorCounts)
                        .sort((a, b) => b[1] - a[1])
                        .map(entry => entry[0]);
                    
                    if (variety) {
                        const varietyColors = [];
                        for (let c of sortedColors) {
                            if (varietyColors.length >= count) break;
                            // Check distance against all currently selected variety colors
                            const isDistinct = varietyColors.every(existing => getColorDistance(existing, c) > 40);
                            if (isDistinct) varietyColors.push(c);
                        }
                        sortedColors = varietyColors;
                    } else {
                        sortedColors = sortedColors.slice(0, count);
                    }
                    
                    if(sortedColors.length > 0) {
                        openModal('newPalette', sortedColors); // Open naming modal
                        return;
                    } 
                }
                closeModal();
            };

            const getCoordinates = (e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const cx = e.touches ? e.touches[0].clientX : e.clientX;
                const cy = e.touches ? e.touches[0].clientY : e.clientY;
                const x = Math.floor((cx - rect.left) * scaleX / (canvas.width / gridSize));
                const y = Math.floor((cy - rect.top) * scaleY / (canvas.height / gridSize));
                return { x, y };
            };

            const getColorWithOpacity = () => {
                if (toolOpacity >= 100) return color;
                const alpha = Math.round(toolOpacity * 2.55).toString(16).padStart(2, '0');
                return `${color}${alpha}`;
            };

            const plotPixel = (x, y, newPixels, colorToUse) => {
                if(x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;
                const idx = y * gridSize + x;
                newPixels[idx] = colorToUse;
            };

            const paint = (cx, cy, tempPixels) => {
                const targets = [{x: cx, y: cy}];
                if(mirrorMode.includes('x')) targets.push({x: gridSize - 1 - cx, y: cy});
                if(mirrorMode.includes('y')) targets.push({x: cx, y: gridSize - 1 - cy});
                if(mirrorMode === 'xy') targets.push({x: gridSize - 1 - cx, y: gridSize - 1 - cy});

                let drawColor = tool === 'eraser' ? null : getColorWithOpacity();
                targets.forEach(pt => {
                    for(let oy = -Math.floor(brushSize/2); oy <= Math.floor((brushSize-1)/2); oy++) {
                        for(let ox = -Math.floor(brushSize/2); ox <= Math.floor((brushSize-1)/2); ox++) {
                            const px = pt.x + ox, py = pt.y + oy;
                            if (tool === 'dither' && (px + py) % 2 !== 0) continue;
                            plotPixel(px, py, tempPixels, drawColor);
                        }
                    }
                });
            };

            const getLinePoints = (x0, y0, x1, y1) => {
                const points = [];
                const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
                const sx = (x0 < x1) ? 1 : -1, sy = (y0 < y1) ? 1 : -1;
                let err = dx - dy;
                while (true) {
                    points.push({x: x0, y: y0});
                    if (x0 === x1 && y0 === y1) break;
                    const e2 = 2 * err;
                    if (e2 > -dy) { err -= dy; x0 += sx; }
                    if (e2 < dx) { err += dx; y0 += sy; }
                }
                return points;
            };

            // --- Handlers ---
            const handleWheel = (e) => {
                const rect = containerRef.current.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const delta = -Math.sign(e.deltaY) * 0.5;
                const newZoom = Math.min(Math.max(0.1, zoom + delta), 40); // Allow zoom < 1
                const scaleFactor = newZoom / zoom;
                const newPanX = mouseX - (mouseX - pan.x) * scaleFactor;
                const newPanY = mouseY - (mouseY - pan.y) * scaleFactor;
                setZoom(newZoom);
                setPan({x: newPanX, y: newPanY});
            };

            const handlePointerDown = (e) => {
                if (activeTab === 'animate' && isPlaying) setIsPlaying(false);
                
                if (panMode || e.button === 1 || (e.shiftKey && tool !== 'lighten')) {
                    e.preventDefault();
                    isPanning.current = true;
                    lastPos.current = { x: e.clientX || e.touches[0].clientX, y: e.clientY || e.touches[0].clientY };
                    return;
                }

                const { x, y } = getCoordinates(e);
                
                if (tool === 'move_pixels') {
                    const idx = y * gridSize + x;
                    const targetColor = activeLayer.pixels[idx];
                    if (!targetColor) return;
                    
                    const selection = [];
                    const stack = [{x, y}];
                    const visited = new Set();
                    const newPixels = [...activeLayer.pixels];

                    while (stack.length) {
                        const {x: cx, y: cy} = stack.pop();
                        const key = `${cx},${cy}`;
                        if(visited.has(key)) continue;
                        visited.add(key);
                        const i = cy * gridSize + cx;
                        if(newPixels[i] === targetColor) {
                            selection.push({x: cx, y: cy, color: newPixels[i]});
                            newPixels[i] = null;
                            if(cx>0) stack.push({x: cx-1, y: cy});
                            if(cx<gridSize-1) stack.push({x: cx+1, y: cy});
                            if(cy>0) stack.push({x: cx, y: cy-1});
                            if(cy<gridSize-1) stack.push({x: cx, y: cy+1});
                        }
                    }
                    if (selection.length > 0) {
                        const newFrames = JSON.parse(JSON.stringify(frames));
                        newFrames[currentFrameIndex].layers = newFrames[currentFrameIndex].layers.map(l => l.id === activeLayerId ? {...l, pixels: newPixels} : l);
                        updateProject(activeProjectId, { frames: newFrames });
                        setFloatingSelection({ pixels: selection, originX: x, originY: y, offsetX: 0, offsetY: 0 });
                        isDrawing.current = true;
                    }
                    return;
                }

                if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;

                if (tool === 'dropper') {
                    let picked = null;
                    currentFrame.layers.slice().reverse().forEach(l => {
                         if(!picked && l.visible && l.pixels[y * gridSize + x]) picked = l.pixels[y * gridSize + x];
                    });
                    if (picked) {
                        const hex = picked.length > 7 ? picked.substring(0, 7) : picked;
                        setColor(hex);
                        addRecentColor(hex);
                    }
                    setTool('pencil');
                    return;
                }

                if (tool === 'bucket' || tool === 'bucket_all') {
                    const targetColor = activeLayer.pixels[y*gridSize+x];
                    const fillCol = getColorWithOpacity();
                    if (targetColor === fillCol) return;
                    const newPixels = [...activeLayer.pixels];
                    
                    if (tool === 'bucket_all') {
                        for(let i=0; i<newPixels.length; i++) if(newPixels[i]===targetColor) newPixels[i] = fillCol;
                    } else {
                        const stack = [{x, y}];
                        const visited = new Set();
                        while(stack.length) {
                            const {x: cx, y: cy} = stack.pop();
                            const key = `${cx},${cy}`;
                            if(visited.has(key)) continue;
                            visited.add(key);
                            const idx = cy*gridSize+cx;
                            if(newPixels[idx] === targetColor) {
                                newPixels[idx] = fillCol;
                                if(cx>0) stack.push({x: cx-1, y: cy});
                                if(cx<gridSize-1) stack.push({x: cx+1, y: cy});
                                if(cy>0) stack.push({x: cx, y: cy-1});
                                if(cy<gridSize-1) stack.push({x: cx, y: cy+1});
                            }
                        }
                    }
                    const newFrames = JSON.parse(JSON.stringify(frames));
                    newFrames[currentFrameIndex].layers = newFrames[currentFrameIndex].layers.map(l => l.id === activeLayerId ? { ...l, pixels: newPixels } : l);
                    saveHistory(newFrames);
                    addRecentColor(color);
                    return;
                }

                isDrawing.current = true;
                lastPos.current = { x, y };
                startDrawPos.current = { x, y };

                if (['line', 'rect', 'circle'].includes(tool)) return; 

                const newPixels = [...activeLayer.pixels];
                if (tool === 'lighten') {
                    const idx = y*gridSize+x;
                    const existing = newPixels[idx];
                    const isDarken = e.shiftKey || darkenMode;
                    if(existing) newPixels[idx] = adjustBrightness(existing, isDarken ? -20 : 20);
                } else {
                    paint(x, y, newPixels);
                    if(tool !== 'eraser' && tool !== 'dither') addRecentColor(color);
                }
                
                const newFrames = JSON.parse(JSON.stringify(frames));
                newFrames[currentFrameIndex].layers = newFrames[currentFrameIndex].layers.map(l => l.id === activeLayerId ? { ...l, pixels: newPixels } : l);
                updateProject(activeProjectId, { frames: newFrames });
            };

            const handlePointerMove = (e) => {
                if (isPanning.current) {
                    const cx = e.clientX || e.touches[0].clientX;
                    const cy = e.clientY || e.touches[0].clientY;
                    const dx = cx - lastPos.current.x;
                    const dy = cy - lastPos.current.y;
                    setPan(p => ({ x: p.x + dx, y: p.y + dy }));
                    lastPos.current = { x: cx, y: cy };
                    return;
                }
                
                const { x, y } = getCoordinates(e);
                setHoverPos({x, y});

                if (!isDrawing.current) return;

                if (tool === 'move_pixels' && floatingSelection) {
                    const dx = x - floatingSelection.originX;
                    const dy = y - floatingSelection.originY;
                    setFloatingSelection(prev => ({ ...prev, offsetX: dx, offsetY: dy }));
                    return;
                }

                if (['line', 'rect', 'circle'].includes(tool)) return; 

                const newPixels = [...activeLayer.pixels];
                getLinePoints(lastPos.current.x, lastPos.current.y, x, y).forEach(pt => {
                    if (tool === 'lighten') {
                        const idx = pt.y*gridSize+pt.x;
                        const isDarken = e.shiftKey || darkenMode;
                        if(idx >= 0 && idx < newPixels.length && newPixels[idx]) {
                            newPixels[idx] = adjustBrightness(newPixels[idx], isDarken ? -20 : 20);
                        }
                    } else {
                        paint(pt.x, pt.y, newPixels);
                    }
                });
                
                const newFrames = JSON.parse(JSON.stringify(frames));
                newFrames[currentFrameIndex].layers = newFrames[currentFrameIndex].layers.map(l => l.id === activeLayerId ? { ...l, pixels: newPixels } : l);
                updateProject(activeProjectId, { frames: newFrames });
                lastPos.current = { x, y };
            };

            const handlePointerUp = (e) => {
                if (isPanning.current) { isPanning.current = false; return; }
                if (!isDrawing.current) return;
                isDrawing.current = false;
                
                if (tool === 'move_pixels' && floatingSelection) {
                    const newPixels = [...activeLayer.pixels];
                    floatingSelection.pixels.forEach(p => {
                        const destX = p.x + floatingSelection.offsetX;
                        const destY = p.y + floatingSelection.offsetY;
                        if(destX >= 0 && destX < gridSize && destY >= 0 && destY < gridSize) {
                            newPixels[destY * gridSize + destX] = p.color;
                        }
                    });
                    const newFrames = JSON.parse(JSON.stringify(frames));
                    newFrames[currentFrameIndex].layers = newFrames[currentFrameIndex].layers.map(l => l.id === activeLayerId ? { ...l, pixels: newPixels } : l);
                    saveHistory(newFrames);
                    setFloatingSelection(null);
                    return;
                }

                const newFrames = JSON.parse(JSON.stringify(frames));
                let newPixels = [...activeLayer.pixels];

                if (['line', 'rect', 'circle'].includes(tool)) {
                   const { x, y } = getCoordinates(e);
                   const x0 = startDrawPos.current.x, y0 = startDrawPos.current.y;
                   const drawColor = getColorWithOpacity();

                   if (tool === 'line') {
                       getLinePoints(x0, y0, x, y).forEach(pt => plotPixel(pt.x, pt.y, newPixels, drawColor));
                   } else if (tool === 'rect') {
                        const rx = Math.min(x0, x), ry = Math.min(y0, y);
                        const rw = Math.abs(x - x0) + 1, rh = Math.abs(y - y0) + 1;
                        for(let i=rx; i<rx+rw; i++) { plotPixel(i, ry, newPixels, drawColor); plotPixel(i, ry+rh-1, newPixels, drawColor); }
                        for(let i=ry; i<ry+rh; i++) { plotPixel(rx, i, newPixels, drawColor); plotPixel(rx+rw-1, i, newPixels, drawColor); }
                   } else if (tool === 'circle') {
                        const r = Math.floor(Math.sqrt(Math.pow(x-x0,2) + Math.pow(y-y0,2)));
                         for(let cy=y0-r; cy<=y0+r; cy++) {
                             for(let cx=x0-r; cx<=x0+r; cx++) {
                                 const dist = Math.sqrt(Math.pow(cx-x0,2) + Math.pow(cy-y0,2));
                                 if (dist >= r - 0.5 && dist <= r + 0.5) plotPixel(cx, cy, newPixels, drawColor);
                             }
                         }
                   }
                   addRecentColor(color);
                   newFrames[currentFrameIndex].layers = newFrames[currentFrameIndex].layers.map(l => l.id === activeLayerId ? { ...l, pixels: newPixels } : l);
                } 
                
                saveHistory(newFrames);
            };

            // --- Layer/Frame Management using updateProject ---
            const updateLayerOpacity = (id, val) => {
                const newFrames = JSON.parse(JSON.stringify(frames));
                newFrames[currentFrameIndex].layers = newFrames[currentFrameIndex].layers.map(l => l.id === id ? { ...l, opacity: val } : l);
                updateProject(activeProjectId, { frames: newFrames });
            };
            const addLayer = () => {
                const newFrames = JSON.parse(JSON.stringify(frames));
                newFrames[currentFrameIndex].layers = [{ id: 'l'+Date.now(), name: `Layer ${newFrames[currentFrameIndex].layers.length+1}`, visible: true, opacity: 100, pixels: Array(gridSize*gridSize).fill(null) }, ...newFrames[currentFrameIndex].layers];
                updateProject(activeProjectId, { frames: newFrames });
                setActiveLayerId(newFrames[currentFrameIndex].layers[0].id);
            };
            const deleteLayer = (lid) => {
                if (currentFrame.layers.length <= 1) return;
                const newFrames = JSON.parse(JSON.stringify(frames));
                newFrames[currentFrameIndex].layers = newFrames[currentFrameIndex].layers.filter(l => l.id !== lid);
                updateProject(activeProjectId, { frames: newFrames });
            };
            const toggleLayerVis = (lid) => {
                const newFrames = JSON.parse(JSON.stringify(frames));
                newFrames[currentFrameIndex].layers = newFrames[currentFrameIndex].layers.map(l => l.id === lid ? { ...l, visible: !l.visible } : l);
                updateProject(activeProjectId, { frames: newFrames });
            };
            const addFrame = () => {
                const newFrames = JSON.parse(JSON.stringify(frames));
                newFrames.splice(currentFrameIndex + 1, 0, { id: 'f'+Date.now(), layers: currentFrame.layers.map(l => ({ ...l, pixels: Array(gridSize*gridSize).fill(null) })) });
                updateProject(activeProjectId, { frames: newFrames });
                setCurrentFrameIndex(currentFrameIndex+1);
            };
            const deleteFrame = (i) => {
                if(frames.length<=1) return;
                const newFrames = frames.filter((_, idx)=>idx!==i);
                updateProject(activeProjectId, { frames: newFrames });
                if(currentFrameIndex>=newFrames.length) setCurrentFrameIndex(newFrames.length-1);
            };
            const copyFrame = () => {
                const newFrames = JSON.parse(JSON.stringify(frames));
                newFrames.splice(currentFrameIndex+1, 0, { ...JSON.parse(JSON.stringify(currentFrame)), id: 'f'+Date.now() });
                updateProject(activeProjectId, { frames: newFrames });
                setCurrentFrameIndex(currentFrameIndex+1);
            };

            // --- Multi-Tab Management ---
            const createNewProject = () => {
                openModal('newProject');
            };

            const closeProject = (e, pid) => {
                e.stopPropagation();
                if (projects.length <= 1) return;
                const newProjs = projects.filter(p => p.id !== pid);
                setProjects(newProjs);
                if (activeProjectId === pid) setActiveProjectId(newProjs[0].id);
            };

            // --- Palette Helper ---
            const addColorToPalette = (paletteId, newColor) => {
                setLibrary(prev => prev.map(folder => {
                    if (folder.id === currentFolderId) {
                         const updatedPalettes = folder.palettes.map(p => {
                             if(p.id === paletteId) {
                                 // Avoid duplicates
                                 if(!p.colors.includes(newColor)) {
                                     return { ...p, colors: [...p.colors, newColor] };
                                 }
                             }
                             return p;
                         });
                         return { ...folder, palettes: updatedPalettes };
                    }
                    return folder;
                }));
            };

            const removeColorFromPalette = (paletteId, colorToRemove) => {
                setLibrary(prev => prev.map(folder => {
                    if (folder.id === currentFolderId) {
                        const updatedPalettes = folder.palettes.map(p => {
                            if(p.id === paletteId) {
                                return { ...p, colors: p.colors.filter(c => c !== colorToRemove) };
                            }
                            return p;
                        });
                        return { ...folder, palettes: updatedPalettes };
                    }
                    return folder;
                }));
            };


            // --- Image Import Logic ---
            const processImportedFile = (file) => {
                if (!file || !file.type.startsWith('image/')) return;
                
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.onload = () => {
                        openModal('imageImportOption', { img });
                    };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(file);
            };

            const handleImageImport = (e) => {
                const file = e.target.files[0];
                if (file) {
                    processImportedFile(file);
                    e.target.value = null; // reset input
                }
            };

            const handlePaletteImageImport = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.onload = () => {
                        setPaletteConfig({ img, count: 8, variety: false });
                        openModal('paletteImportOptions');
                    };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(file);
                e.target.value = null;
            };


            const handleDrop = (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (file) processImportedFile(file);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
            };

            const processImageImport = (mode, img) => {
                // mode: 'new' (resize grid to fit) or 'current' (fit to current grid)
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                let targetSize = gridSize;
                let newGridSize = gridSize;

                if (mode === 'new') {
                    // Determine best grid size (max 64 to keep performance sane)
                    const maxDim = Math.max(img.width, img.height);
                    newGridSize = Math.min(64, Math.ceil(maxDim / 10) * 10); // Round to nearest 10, max 64
                    // Or just use 32/64 presets? Let's use 64 max
                    if (newGridSize < 16) newGridSize = 16;
                    targetSize = newGridSize;
                }

                canvas.width = targetSize;
                canvas.height = targetSize;
                
                // Draw and resize
                ctx.drawImage(img, 0, 0, targetSize, targetSize);
                const data = ctx.getImageData(0, 0, targetSize, targetSize).data;
                
                // Convert to pixels
                const newPixels = new Array(targetSize * targetSize).fill(null);
                for(let i=0; i<data.length; i+=4) {
                    if(data[i+3] > 10) { // Transparency check
                        newPixels[i/4] = rgbToHex(data[i], data[i+1], data[i+2]);
                    }
                }

                if (mode === 'new') {
                    const newId = 'p' + Date.now();
                    const newProj = createNewProjectData(newId, 'Imported Image', newGridSize);
                    newProj.frames[0].layers[0].pixels = newPixels;
                    newProj.history = [JSON.parse(JSON.stringify(newProj.frames))];
                    newProj.historyIndex = 0;
                    setProjects([...projects, newProj]);
                    setActiveProjectId(newId);
                } else {
                    const newFrames = JSON.parse(JSON.stringify(frames));
                    // Combine with current layer
                    const currentPixels = newFrames[currentFrameIndex].layers.find(l=>l.id===activeLayerId).pixels;
                    for(let i=0; i<newPixels.length; i++) {
                        if(newPixels[i]) currentPixels[i] = newPixels[i];
                    }
                    saveHistory(newFrames);
                }
                closeModal();
            };

            const exportSheet = () => {
                const canvas = document.createElement('canvas');
                canvas.width = gridSize;
                canvas.height = gridSize * frames.length; 
                const ctx = canvas.getContext('2d');
                frames.forEach((frame, idx) => {
                    const offsetY = idx * gridSize; 
                    frame.layers.slice().reverse().forEach(l => {
                        if(l.visible) {
                            l.pixels.forEach((c, i) => { 
                                if(c) { 
                                    ctx.fillStyle = c; 
                                    ctx.fillRect((i % gridSize), Math.floor(i / gridSize) + offsetY, 1, 1); 
                                } 
                            });
                        }
                    });
                });
                const link = document.createElement('a');
                link.download = `${currentProject.name}.png`;
                link.href = canvas.toDataURL();
                link.click();
            };

            // Mobile Tab Logic
            const handleTabClick = (tabId) => {
                if (window.innerWidth < 768) {
                    // Mobile behavior
                    if (activeTab === tabId) {
                        // If tapping active tab, toggle open/close
                        setIsMobilePanelOpen(!isMobilePanelOpen);
                    } else {
                        // If tapping new tab, switch and open
                        setActiveTab(tabId);
                        setIsMobilePanelOpen(true);
                    }
                } else {
                    // Desktop behavior
                    setActiveTab(tabId);
                }
            };

            const currentFolder = library.find(f => f.id === currentFolderId) || library[0];

            return (
                <div 
                    className="flex flex-col h-[100dvh] font-sans overflow-hidden bg-space-900" 
                    onContextMenu={e => e.preventDefault()}
                    onDrop={handleDrop}
                    onDragOver={handleDragOver}
                >
                    <SpaceBackground />
                    
                    {/* Header with Banner Background */}
                    <header className="relative flex justify-between items-center z-20 mx-2 mt-2 rounded-xl overflow-hidden shadow-lg border border-tech-glow shrink-0 h-12 md:h-14 bg-space-900">
                        {/* Background Image & Overlay */}
                        <div className="absolute inset-0 bg-cover bg-center z-0 hidden md:block" style={{backgroundImage: "url('Omni-Science Banner.jpg')"}}></div>
                        <div className="absolute inset-0 bg-space-900/90 md:bg-space-900/80 backdrop-blur-sm z-0"></div>

                        <div className="relative z-10 flex items-center gap-3 p-2 w-full">
                            <div className="w-8 h-8 md:w-10 md:h-10 bg-gradient-to-br from-tech-500 to-blue-600 rounded-lg flex items-center justify-center shadow-[0_0_15px_rgba(34,211,238,0.5)] overflow-hidden shrink-0">
                                <img src="Omni-Science Logo.jpg" className="w-full h-full object-cover" alt="Logo" onError={(e) => {e.target.style.display='none'; e.target.parentNode.innerHTML = '<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'white\' stroke-width=\'2\'><path d=\'M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5\'/></svg>'}} />
                            </div>
                            <div className="overflow-hidden">
                                <h1 className="text-lg md:text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-tech-400 to-blue-400 tracking-wider truncate">OMNI-PIX</h1>
                            </div>
                            <div className="flex-1"></div>
                            <div className="flex items-center gap-1 md:gap-2">
                                <button onClick={undo} disabled={currentProject.historyIndex<=0} className="p-1 md:p-2 text-tech-400 hover:text-white disabled:opacity-30 transition-colors"><Icons.Undo /></button>
                                <button onClick={redo} disabled={currentProject.historyIndex>=currentProject.history.length-1} className="p-1 md:p-2 text-tech-400 hover:text-white disabled:opacity-30 transition-colors"><Icons.Redo /></button>
                                <div className="w-px h-4 md:h-6 bg-space-700 mx-1 md:mx-2"></div>
                                <div className="hidden md:flex bg-space-900/50 rounded-lg p-1 gap-1 border border-space-700">
                                    {[16, 32, 64].map(s => <button key={s} onClick={() => openModal('confirm-resize', s)} className={`px-3 py-1 text-xs font-bold rounded-md transition-all ${gridSize===s?'bg-tech-500 text-white shadow-[0_0_10px_rgba(6,182,212,0.5)]':'text-gray-400 hover:text-tech-400'}`}>{s}x</button>)}
                                    <button onClick={() => openModal('resize')} className="px-3 py-1 text-xs font-bold rounded-md text-gray-400 hover:text-tech-400 transition-colors">Custom</button>
                                </div>
                                {/* Mobile Resize Button */}
                                <button onClick={() => openModal('resize')} className="md:hidden p-2 text-gray-300 hover:text-white bg-space-800 rounded-lg border border-space-600">
                                    <Icons.Resize />
                                </button>
                                
                                <input type="file" ref={imageImportRef} className="hidden" accept="image/*" onChange={handleImageImport} />
                                <button onClick={() => imageImportRef.current.click()} className="flex items-center gap-2 bg-space-800 hover:bg-space-700 text-gray-300 px-2 py-1 md:px-3 md:py-2 rounded-lg text-xs md:text-sm font-bold border border-space-600 transition-all">
                                    <Icons.Image /> <span className="hidden md:inline">Import</span>
                                </button>
                                <button onClick={exportSheet} className="flex items-center gap-2 bg-gradient-to-r from-tech-500 to-blue-600 hover:from-tech-400 hover:to-blue-500 text-white px-2 py-1 md:px-4 md:py-2 rounded-lg text-xs md:text-sm font-bold shadow-[0_0_15px_rgba(6,182,212,0.3)] transition-all hover:scale-105">
                                    <Icons.Download /> <span className="hidden md:inline">Export</span>
                                </button>
                            </div>
                        </div>
                    </header>

                    {/* Tab Bar */}
                    <div className="flex items-center mx-2 mt-1 gap-1 overflow-x-auto hide-scrollbar z-10 shrink-0 h-10">
                        {projects.map(p => (
                            <div key={p.id} onClick={() => setActiveProjectId(p.id)}
                                className={`group flex items-center gap-2 px-4 py-2 rounded-t-lg text-xs font-bold cursor-pointer select-none transition-all min-w-[100px] md:min-w-[120px] max-w-[150px] md:max-w-[200px] border-t border-x ${activeProjectId === p.id ? 'bg-space-800 border-tech-500/30 text-tech-400 relative bottom-[-1px] z-20' : 'bg-space-900/50 border-space-700 text-gray-500 hover:bg-space-800/80 hover:text-gray-300'}`}>
                                <span className="truncate">{p.name}</span>
                                {projects.length > 1 && (
                                    <button onClick={(e) => closeProject(e, p.id)} className="md:opacity-0 group-hover:opacity-100 hover:text-red-400 transition-opacity ml-auto"><Icons.Close /></button>
                                )}
                            </div>
                        ))}
                        <button onClick={createNewProject} className="px-3 py-2 text-gray-500 hover:text-tech-400 transition-colors" title="New Project">
                            <Icons.Plus />
                        </button>
                    </div>

                    <div className="flex flex-col md:flex-row flex-1 overflow-hidden p-2 gap-2 pt-0 z-10 relative min-h-0">
                        {/* Tools Toolbar - Mobile: Top Scrollable / Desktop: Left Vertical */}
                        <aside className="w-full md:w-16 h-12 md:h-auto glass-panel rounded-xl flex flex-row md:flex-col items-center py-2 md:py-4 px-2 md:px-0 gap-3 z-20 overflow-x-auto md:overflow-y-auto hide-scrollbar relative shrink-0 order-1">
                            
                            {/* Mobile Tool Settings Toggle */}
                            <button className="md:hidden flex-shrink-0 p-2 rounded-xl transition-all relative text-tech-400 hover:bg-space-700" onClick={() => setIsMobileToolOptionsOpen(!isMobileToolOptionsOpen)}>
                                <Icons.Gear />
                            </button>
                            <div className="md:hidden w-px h-6 bg-space-700 flex-shrink-0"></div>

                            {TOOLS.map(t => (
                                <button 
                                    key={t.id} 
                                    onClick={() => setTool(t.id)} 
                                    onMouseEnter={(e) => window.innerWidth > 768 && setTooltip({
                                        text: (
                                            <div>
                                                <span className="font-bold">{t.label}</span> <span className="opacity-70">({t.binding})</span>
                                                <div className="text-[10px] opacity-80 mt-1 font-normal">{t.desc}</div>
                                            </div>
                                        ),
                                        top: e.currentTarget.getBoundingClientRect().top, 
                                        left: e.currentTarget.getBoundingClientRect().right + 10
                                    })}
                                    onMouseLeave={() => setTooltip(null)}
                                    className={`flex-shrink-0 p-2 md:p-3 rounded-xl transition-all relative group ${tool===t.id ? 'bg-tech-500 text-white shadow-[0_0_15px_rgba(6,182,212,0.6)] md:scale-110' : 'text-gray-400 hover:bg-space-700 hover:text-tech-400'}`}>
                                    <t.icon />
                                </button>
                            ))}
                            <div className="w-px h-6 md:w-8 md:h-px bg-space-700 my-0 md:my-1 flex-shrink-0"></div>
                            <div className="hidden md:flex flex-col gap-2">
                                {['x', 'y', 'xy'].map(m => (
                                    <button key={m} onClick={() => setMirrorMode(prev => prev === m ? 'none' : m)} 
                                        className={`flex-shrink-0 text-[10px] font-bold w-8 h-8 rounded flex items-center justify-center uppercase border border-space-700 transition-all ${mirrorMode === m ? 'bg-blue-600 text-white border-blue-400 shadow-[0_0_10px_rgba(37,99,235,0.5)]' : 'bg-space-900 text-gray-500 hover:text-white'}`}>
                                        {m}
                                    </button>
                                ))}
                            </div>
                             <div className="flex-1 md:flex-none"></div>
                             <button onClick={() => openModal('clear')} className="text-red-400 hover:bg-red-900/30 p-2 rounded transition-colors flex-shrink-0"><Icons.Trash /></button>
                        </aside>

                        {/* Mobile Tool Options Panel */}
                        {isMobileToolOptionsOpen && (
                            <div className="absolute top-14 left-2 right-2 z-40 bg-space-800 border border-tech-glow rounded-xl p-3 flex flex-col gap-3 shadow-2xl md:hidden">
                                <div className="flex justify-between items-center border-b border-space-700 pb-2 mb-1">
                                    <span className="text-xs font-bold text-tech-400 uppercase flex items-center gap-2">
                                        {currentToolDef?.icon && <currentToolDef.icon />}
                                        {currentToolDef?.label} Options
                                    </span>
                                    <button onClick={() => setIsMobileToolOptionsOpen(false)}><Icons.Close /></button>
                                </div>
                                
                                <div className="space-y-3">
                                    {/* Brush Size for applicable tools (Hidden for Bucket) */}
                                    {['pencil', 'eraser', 'lighten', 'dither'].includes(tool) && (
                                        <div className="space-y-1">
                                            <div className="flex justify-between text-[10px] text-gray-400">
                                                <span>SIZE</span><span>{brushSize}px</span>
                                            </div>
                                            <input type="range" min="1" max="8" value={brushSize} onChange={e => setBrushSize(parseInt(e.target.value))} className="w-full h-1 bg-space-900 rounded-lg appearance-none cursor-pointer range-sm" />
                                        </div>
                                    )}

                                    {/* Opacity for applicable tools (Visible for Bucket) */}
                                    {['pencil', 'eraser', 'lighten', 'dither', 'bucket', 'bucket_all'].includes(tool) && (
                                        <div className="space-y-1">
                                            <div className="flex justify-between text-[10px] text-gray-400">
                                                <span>OPACITY</span><span>{toolOpacity}%</span>
                                            </div>
                                            <input type="range" min="10" max="100" value={toolOpacity} onChange={e => setToolOpacity(parseInt(e.target.value))} className="w-full h-1 bg-space-900 rounded-lg appearance-none cursor-pointer range-sm" />
                                        </div>
                                    )}
                                </div>

                                {/* Mirror Mode (Available for all drawing tools) */}
                                <div className="space-y-1">
                                    <span className="text-[10px] text-gray-400 uppercase">Mirror Mode</span>
                                    <div className="flex gap-2">
                                        {['x', 'y', 'xy'].map(m => (
                                            <button key={m} onClick={() => setMirrorMode(prev => prev === m ? 'none' : m)} 
                                                className={`flex-1 py-1.5 text-xs font-bold rounded flex items-center justify-center uppercase border border-space-700 transition-all ${mirrorMode === m ? 'bg-blue-600 text-white border-blue-400' : 'bg-space-900 text-gray-500'}`}>
                                                {m}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Pan Mode Toggle */}
                                <div className="flex items-center justify-between pt-2 border-t border-space-700">
                                    <span className="text-xs text-gray-300">Pan Mode (Drag)</span>
                                    <button onClick={() => setPanMode(!panMode)} className={`w-10 h-5 rounded-full relative transition-colors ${panMode ? 'bg-tech-500' : 'bg-space-600'}`}>
                                        <div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-all ${panMode ? 'left-6' : 'left-1'}`}></div>
                                    </button>
                                </div>

                                {/* Lighten/Darken Toggle - Only show for Lighten tool */}
                                {tool === 'lighten' && (
                                    <div className="flex items-center justify-between">
                                        <span className="text-xs text-gray-300">Mode: {darkenMode ? 'Darken' : 'Lighten'}</span>
                                        <button onClick={() => setDarkenMode(!darkenMode)} className={`w-10 h-5 rounded-full relative transition-colors ${darkenMode ? 'bg-purple-500' : 'bg-yellow-500'}`}>
                                            <div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-all ${darkenMode ? 'left-6' : 'left-1'}`}></div>
                                        </button>
                                    </div>
                                )}

                                {/* Generic Tool Description (Visible for ALL tools on mobile now) */}
                                {tool !== 'lighten' && (
                                    <div className="text-[10px] text-gray-500 italic mt-1 border-t border-space-700 pt-2">
                                        {currentToolDef?.desc || "No extra options for this tool."}
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Main Canvas Area */}
                        <main className="flex-1 relative overflow-hidden rounded-xl border border-space-700 bg-space-900/30 backdrop-blur-sm order-2 md:order-2 canvas-touch-area min-h-0" 
                            onPointerDown={handlePointerDown} 
                            onPointerMove={handlePointerMove} 
                            onPointerUp={handlePointerUp}
                            onWheel={handleWheel}>
                            
                            <div className="absolute inset-0 pointer-events-none opacity-20" 
                                style={{backgroundImage: 'linear-gradient(rgba(34, 211, 238, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(34, 211, 238, 0.1) 1px, transparent 1px)', backgroundSize: '40px 40px'}}>
                            </div>

                            <div ref={containerRef} className="absolute w-full h-full overflow-hidden touch-none">
                                <div className="relative shadow-[0_0_50px_rgba(0,0,0,0.5)] bg-space-800 flex-shrink-0" 
                                    style={{
                                        transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`, 
                                        transformOrigin: '0 0',
                                        width: 512, height: 512,
                                        imageRendering: 'pixelated',
                                        cursor: isPanning.current || panMode ? 'grabbing' : 'crosshair',
                                        boxShadow: '0 0 0 1px rgba(255,255,255,0.1)'
                                    }}>
                                    <canvas ref={canvasRef} width={gridSize*10} height={gridSize*10} className="w-full h-full block" />
                                </div>
                            </div>

                            <div className="absolute bottom-4 left-4 glass-panel px-4 py-2 rounded-full text-xs font-mono text-tech-400 pointer-events-none flex items-center gap-4 z-20" style={{bottom: isMobilePanelOpen ? '65vh' : '3rem', transition: 'bottom 0.3s'}}>
                                <span className="opacity-70">COORD: {hoverPos ? `${hoverPos.x},${hoverPos.y}` : '-,-'}</span>
                                <span className="w-px h-3 bg-space-600"></span>
                                <span>{gridSize}x{gridSize}</span>
                                <span className="w-px h-3 bg-space-600 hidden md:block"></span>
                                <span className="hidden md:block">{Math.round(zoom*100)}%</span>
                                <button onClick={() => {fitToScreen();}} className="pointer-events-auto hover:text-white hover:scale-110 transition-transform" title="Fit to Screen"><Icons.Center /></button>
                            </div>
                            
                            <div className="absolute bottom-3 right-4 text-[10px] text-gray-500 font-mono opacity-50 pointer-events-none hidden md:block">
                                Omni-Pix Studio v2.0
                            </div>
                        </main>

                        {/* Right Panel - Mobile: Collapsible Drawer / Desktop: Right Side */}
                        <aside className={`fixed bottom-0 left-0 right-0 z-30 flex flex-col glass-panel transition-all duration-300 md:relative md:w-72 md:h-auto md:z-10 md:order-3 md:rounded-xl md:bg-opacity-100 md:translate-y-0
                            ${isMobilePanelOpen ? 'h-[65vh] rounded-t-xl' : 'h-6 rounded-t-xl md:h-auto'}`}>
                            
                            {/* Drawer Toggle Handle (Mobile Only) */}
                            <div className="md:hidden flex justify-center items-center h-6 w-full cursor-pointer bg-space-800/80 hover:bg-space-700/80 rounded-t-xl border-t border-x border-tech-glow/30" onClick={() => setIsMobilePanelOpen(!isMobilePanelOpen)}>
                                {isMobilePanelOpen ? <Icons.ChevronDown /> : <Icons.ChevronUp />}
                            </div>

                            {/* Color & Brush Settings - Hidden when mobile drawer collapsed */}
                            <div className={`p-3 md:p-4 border-b border-space-700 ${!isMobilePanelOpen ? 'hidden md:block' : ''}`}>
                                <div className="flex justify-between items-end mb-2">
                                    <span className="text-xs font-bold text-gray-400 uppercase tracking-wider">Color</span>
                                    <span className="text-[10px] font-mono text-tech-400">{color}</span>
                                </div>
                                <div className="flex gap-3 mb-2 md:mb-4">
                                    <div className="relative w-10 h-10 md:w-12 md:h-12 rounded-lg overflow-hidden border border-gray-600 shadow-inner group">
                                        <input type="color" value={color} onChange={e => { setColor(e.target.value); }} className="absolute -top-2 -left-2 w-16 h-16 cursor-pointer p-0 border-0 opacity-0" />
                                        <div className="w-full h-full" style={{backgroundColor: color}}></div>
                                    </div>
                                    {/* Size/Opacity - HIDDEN ON MOBILE (Moved to Tool Options) */}
                                    <div className="flex-1 space-y-1 md:space-y-2 hidden md:block">
                                        <div>
                                            <div className="flex justify-between text-[10px] text-gray-400 mb-px"><span>SIZE</span><span>{brushSize}px</span></div>
                                            <input type="range" min="1" max="8" value={brushSize} onChange={e => setBrushSize(parseInt(e.target.value))} className="w-full h-1 bg-space-900 rounded-lg appearance-none cursor-pointer range-sm" />
                                        </div>
                                        <div>
                                            <div className="flex justify-between text-[10px] text-gray-400 mb-px"><span>OPACITY</span><span>{toolOpacity}%</span></div>
                                            <input type="range" min="10" max="100" value={toolOpacity} onChange={e => setToolOpacity(parseInt(e.target.value))} className="w-full h-1 bg-space-900 rounded-lg appearance-none cursor-pointer range-sm" />
                                        </div>
                                    </div>
                                </div>
                                <div className="flex gap-1 overflow-x-auto hide-scrollbar pb-1">
                                    {recentColors.map((c, i) => (
                                        <button key={i} onClick={() => setColor(c)} style={{backgroundColor: c}} className="w-6 h-6 rounded flex-shrink-0 border border-gray-600 hover:scale-110 transition-transform"></button>
                                    ))}
                                </div>
                            </div>

                            {/* Tabs Navigation */}
                            <div className={`flex border-b border-space-700 ${!isMobilePanelOpen ? 'hidden md:flex' : ''}`}>
                                {['layers', 'palettes', 'animate'].map(tab => (
                                    <button key={tab} 
                                        onClick={() => handleTabClick(tab)}
                                        className={`flex-1 py-2 text-xs font-bold uppercase tracking-wider transition-colors ${activeTab === tab ? 'tab-active' : 'tab-inactive'}`}>
                                        {tab}
                                    </button>
                                ))}
                            </div>

                            {/* Tab Content */}
                            <div className={`flex-1 overflow-y-auto p-2 ${!isMobilePanelOpen ? 'hidden md:block' : ''}`}>
                                
                                {activeTab === 'layers' && (
                                    <div className="space-y-2">
                                        <div className="flex justify-between items-center mb-2 px-1">
                                            <span className="text-xs text-gray-400 uppercase font-bold">Layers ({currentFrame.layers.length})</span>
                                            <button onClick={addLayer} className="p-1 text-tech-400 hover:text-white hover:bg-space-700 rounded"><Icons.Plus /></button>
                                        </div>
                                        <div className="space-y-1">
                                            {currentFrame.layers.map(l => (
                                                <div key={l.id} onClick={() => setActiveLayerId(l.id)}
                                                    className={`p-2 rounded-lg border flex items-center gap-2 group ${activeLayerId===l.id ? 'bg-space-800 border-tech-500/50' : 'bg-transparent border-transparent hover:bg-space-800/50'}`}>
                                                    <button onClick={(e) => { e.stopPropagation(); toggleLayerVis(l.id); }} className={`p-1 rounded ${l.visible ? 'text-tech-400' : 'text-gray-600'}`}>
                                                        {l.visible ? <Icons.Eye /> : <Icons.EyeOff />}
                                                    </button>
                                                    <div className="flex-1 min-w-0">
                                                        <div className="text-xs font-medium truncate text-gray-300">{l.name}</div>
                                                        <input type="range" min="0" max="100" value={l.opacity} 
                                                            onClick={e => e.stopPropagation()}
                                                            onChange={(e) => updateLayerOpacity(l.id, parseInt(e.target.value))} 
                                                            className="w-full h-1 bg-space-900 rounded appearance-none cursor-pointer mt-1 range-sm opacity-50 hover:opacity-100" />
                                                    </div>
                                                    <button onClick={(e) => { e.stopPropagation(); deleteLayer(l.id); }} className="opacity-0 group-hover:opacity-100 p-1 text-red-400 hover:text-red-300"><Icons.Trash /></button>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                {activeTab === 'palettes' && (
                                    <div className="space-y-4">
                                        <div className="flex justify-between items-center px-1">
                                            <span className="text-xs text-gray-400 uppercase font-bold">Library</span>
                                            <input type="file" ref={paletteImageImportRef} className="hidden" accept="image/*" onChange={handlePaletteImageImport} />
                                            <div className="flex gap-1">
                                                <button onClick={() => paletteImageImportRef.current.click()} className="p-1 text-gray-400 hover:text-white" title="Import from Image"><Icons.Image /></button>
                                                <button onClick={() => openModal('newFolder')} className="p-1 text-gray-400 hover:text-white"><Icons.Folder /></button>
                                            </div>
                                        </div>
                                        
                                        {/* Folder Select */}
                                        <select value={currentFolderId} onChange={e => setCurrentFolderId(e.target.value)} 
                                            className="w-full bg-space-800 border border-space-600 rounded p-1 text-xs text-gray-300 outline-none focus:border-tech-500">
                                            {library.map(f => <option key={f.id} value={f.id}>{f.name}</option>)}
                                        </select>

                                        {/* Palettes in current folder */}
                                        <div className="space-y-3">
                                            <button onClick={() => openModal('newPalette')} className="w-full py-2 border-2 border-dashed border-space-600 rounded-lg text-xs text-gray-500 hover:border-tech-500 hover:text-tech-400 transition-all">
                                                + New Palette
                                            </button>
                                            
                                            {currentFolder.palettes.map(pal => (
                                                <div key={pal.id} className="bg-space-800/50 rounded-lg p-2 border border-space-700">
                                                    <div className="flex justify-between items-center mb-2">
                                                        <span className="text-xs font-bold text-tech-400">{pal.name}</span>
                                                        <button onClick={() => {
                                                            const newLibrary = library.map(f => f.id === currentFolderId ? { ...f, palettes: f.palettes.filter(p => p.id !== pal.id) } : f);
                                                            setLibrary(newLibrary);
                                                        }} className="text-gray-600 hover:text-red-400"><Icons.Close /></button>
                                                    </div>
                                                    <div className="flex flex-wrap gap-1">
                                                        {pal.colors.map((c, i) => (
                                                            <div key={i} className="group relative w-6 h-6 rounded cursor-pointer border border-transparent hover:border-white hover:scale-110 transition-all"
                                                                style={{backgroundColor: c}}
                                                                onClick={() => setColor(c)}>
                                                                <div className="hidden group-hover:flex absolute -top-8 left-1/2 -translate-x-1/2 bg-black text-[10px] px-1 rounded text-white z-50 pointer-events-none">
                                                                    {c}
                                                                </div>
                                                                <button onClick={(e) => { e.stopPropagation(); removeColorFromPalette(pal.id, c); }} 
                                                                    className="hidden group-hover:flex absolute -bottom-2 -right-2 bg-red-500 w-3 h-3 rounded-full items-center justify-center text-[8px] text-white">x</button>
                                                            </div>
                                                        ))}
                                                        <button onClick={() => openModal('addSwatch', { paletteId: pal.id })} className="w-6 h-6 rounded border border-dashed border-gray-500 flex items-center justify-center text-gray-500 hover:text-white hover:border-white">
                                                            +
                                                        </button>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                {activeTab === 'animate' && (
                                    <div className="space-y-4">
                                        <div className="flex justify-between items-center px-1">
                                            <span className="text-xs text-gray-400 uppercase font-bold">Animation</span>
                                            <div className="flex items-center gap-2">
                                                <span className="text-[10px] text-gray-500">ONION</span>
                                                <button onClick={() => setOnionSkin(!onionSkin)} className={`w-8 h-4 rounded-full relative transition-colors ${onionSkin ? 'bg-tech-500' : 'bg-space-600'}`}>
                                                    <div className={`absolute top-0.5 w-3 h-3 bg-white rounded-full transition-all ${onionSkin ? 'left-4.5' : 'left-0.5'}`}></div>
                                                </button>
                                            </div>
                                        </div>

                                        <div className="bg-space-800 rounded-lg p-2 flex items-center gap-2 justify-center">
                                            <button onClick={() => setIsPlaying(!isPlaying)} className={`p-2 rounded-full ${isPlaying ? 'bg-tech-500 text-white shadow-lg shadow-cyan-500/20' : 'bg-space-700 text-gray-300 hover:bg-space-600'}`}>
                                                {isPlaying ? <Icons.Pause /> : <Icons.Play />}
                                            </button>
                                            <div className="flex-1 px-2">
                                                <div className="flex justify-between text-[10px] text-gray-400 mb-1">
                                                    <span>SPEED</span>
                                                    <span>{currentProject.fps} FPS</span>
                                                </div>
                                                <input type="range" min="1" max="24" value={currentProject.fps} 
                                                    onChange={e => updateProject(activeProjectId, { fps: parseInt(e.target.value) })}
                                                    className="w-full h-1 bg-space-900 rounded appearance-none cursor-pointer range-sm" />
                                            </div>
                                        </div>

                                        <div className="space-y-2">
                                            <div className="grid grid-cols-4 gap-2">
                                                {frames.map((f, i) => (
                                                    <div key={f.id} onClick={() => { setIsPlaying(false); setCurrentFrameIndex(i); }}
                                                        className={`relative aspect-square bg-space-800 rounded border cursor-pointer group ${currentFrameIndex === i ? 'border-tech-400 shadow-[0_0_10px_rgba(34,211,238,0.2)]' : 'border-space-700 hover:border-gray-500'}`}>
                                                        <div className="absolute top-1 left-1 text-[8px] bg-black/50 px-1 rounded text-gray-300">{i+1}</div>
                                                        {/* Mini preview logic could go here */}
                                                        <div className="w-full h-full flex items-center justify-center text-xs text-gray-600 font-mono">
                                                            FRM
                                                        </div>
                                                        <div className="absolute inset-0 bg-black/50 hidden group-hover:flex items-center justify-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                                            <button onClick={(e) => { e.stopPropagation(); copyFrame(); }} className="text-white hover:text-tech-400"><Icons.Copy /></button>
                                                            <button onClick={(e) => { e.stopPropagation(); deleteFrame(i); }} className="text-red-400 hover:text-red-300"><Icons.Trash /></button>
                                                        </div>
                                                    </div>
                                                ))}
                                                <button onClick={addFrame} className="aspect-square rounded border border-dashed border-space-600 flex items-center justify-center text-gray-500 hover:text-tech-400 hover:border-tech-400 transition-colors">
                                                    <Icons.Plus />
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </aside>
                    </div>

                    {/* Modals */}
                    <Modal isOpen={modalConfig.isOpen} 
                           title={
                               modalConfig.type === 'newFolder' ? 'New Folder' : 
                               modalConfig.type === 'newPalette' ? 'Save Palette' : 
                               modalConfig.type === 'resize' ? 'Resize Canvas' :
                               modalConfig.type === 'confirm-resize' ? 'Confirm Resize' :
                               modalConfig.type === 'newProject' ? 'New Project' :
                               modalConfig.type === 'addSwatch' ? 'Add Swatch' :
                               modalConfig.type === 'imageImportOption' ? 'Import Mode' :
                               modalConfig.type === 'paletteImportOptions' ? 'Palette Settings' :
                               'Confirm Action'
                           }
                           showConfirm={modalConfig.type !== 'imageImportOption'}
                           confirmText={
                                modalConfig.type === 'newProject' ? 'Create' :
                                modalConfig.type === 'addSwatch' ? 'Add' :
                                'Confirm'
                           }
                           onClose={closeModal} 
                           onConfirm={handleModalConfirm}>
                        
                        {(modalConfig.type === 'newFolder' || modalConfig.type === 'newPalette') && (
                            <input type="text" placeholder="Enter name..." autoFocus
                                className="w-full bg-space-900 border border-space-600 p-2 rounded text-white outline-none focus:border-tech-500"
                                value={inputValue} onChange={e => setInputValue(e.target.value)} />
                        )}
                        
                        {modalConfig.type === 'resize' && (
                            <div className="space-y-4">
                                <div className="flex gap-2 justify-between">
                                    {[16, 32, 64].map(size => (
                                        <button key={size} 
                                            onClick={() => setInputNumberValue(size)}
                                            className={`flex-1 py-2 rounded border text-sm font-bold transition-all ${inputNumberValue === size ? 'bg-tech-500 border-tech-400 text-white' : 'bg-space-900 border-space-600 text-gray-400 hover:bg-space-700'}`}>
                                            {size}x
                                        </button>
                                    ))}
                                </div>
                                <div>
                                    <label className="text-xs text-gray-400 mb-1 block">Custom Size (max 128)</label>
                                    <input type="number" min="1" max="128"
                                        className="w-full bg-space-900 border border-space-600 p-2 rounded text-white outline-none focus:border-tech-500"
                                        value={inputNumberValue} onChange={e => setInputNumberValue(parseInt(e.target.value))} />
                                </div>
                                <p className="text-xs text-red-400 mt-2">Warning: Resizing will clear the current canvas.</p>
                            </div>
                        )}

                        {modalConfig.type === 'newProject' && (
                            <div className="space-y-4">
                                <div>
                                    <label className="text-xs text-gray-400 mb-1 block">Project Name</label>
                                    <input type="text" placeholder="My Awesome Art" autoFocus
                                        className="w-full bg-space-900 border border-space-600 p-2 rounded text-white outline-none focus:border-tech-500"
                                        value={inputValue} onChange={e => setInputValue(e.target.value)} />
                                </div>
                                <div className="space-y-2">
                                    <label className="text-xs text-gray-400 block">Canvas Size</label>
                                    <div className="flex gap-2 justify-between">
                                        {[16, 32, 64].map(size => (
                                            <button key={size} 
                                                onClick={() => setInputNumberValue(size)}
                                                className={`flex-1 py-2 rounded border text-sm font-bold transition-all ${inputNumberValue === size ? 'bg-tech-500 border-tech-400 text-white' : 'bg-space-900 border-space-600 text-gray-400 hover:bg-space-700'}`}>
                                                {size}x
                                            </button>
                                        ))}
                                    </div>
                                    <input type="number" min="8" max="128"
                                        className="w-full bg-space-900 border border-space-600 p-2 rounded text-white outline-none focus:border-tech-500 text-center"
                                        value={inputNumberValue} onChange={e => setInputNumberValue(parseInt(e.target.value))} />
                                </div>
                            </div>
                        )}

                        {modalConfig.type === 'addSwatch' && (
                            <div className="space-y-4">
                                <button onClick={() => setNewSwatchColor(color)} className="w-full flex items-center justify-between p-3 bg-space-900 border border-space-600 rounded hover:border-tech-500 group">
                                    <span className="text-sm text-gray-300">Use Current Color</span>
                                    <div className="w-6 h-6 rounded border border-gray-500" style={{backgroundColor: color}}></div>
                                </button>
                                
                                <div className="relative border-t border-space-700 pt-4">
                                    <label className="text-xs text-gray-400 mb-2 block">Or Pick New Color</label>
                                    <div className="flex gap-3 items-center">
                                        <div className="relative w-12 h-12 rounded-lg overflow-hidden border border-gray-600">
                                            <input type="color" value={newSwatchColor} onChange={e => setNewSwatchColor(e.target.value)} className="absolute -top-2 -left-2 w-16 h-16 cursor-pointer p-0 border-0 opacity-0" />
                                            <div className="w-full h-full" style={{backgroundColor: newSwatchColor}}></div>
                                        </div>
                                        <div className="text-sm font-mono text-gray-300">{newSwatchColor}</div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {modalConfig.type === 'paletteImportOptions' && (
                            <div className="space-y-4">
                                <p className="text-sm text-gray-400">Settings for extracting colors from your image.</p>
                                
                                <div>
                                    <div className="flex justify-between text-xs text-gray-400 mb-1">
                                        <span>Max Colors</span>
                                        <span>{paletteConfig.count}</span>
                                    </div>
                                    <input type="range" min="4" max="32" value={paletteConfig.count} 
                                        onChange={e => setPaletteConfig({ ...paletteConfig, count: parseInt(e.target.value) })}
                                        className="w-full h-1 bg-space-900 rounded appearance-none cursor-pointer range-sm" />
                                </div>

                                <div className="flex items-center gap-3 p-3 bg-space-900 rounded border border-space-600">
                                    <input type="checkbox" id="varietyToggle" 
                                        checked={paletteConfig.variety} 
                                        onChange={e => setPaletteConfig({ ...paletteConfig, variety: e.target.checked })}
                                        className="w-4 h-4 rounded border-gray-600 text-tech-500 focus:ring-tech-500 bg-space-800" />
                                    <div>
                                        <label htmlFor="varietyToggle" className="text-sm font-bold text-gray-300 block">Variety Mode</label>
                                        <span className="text-xs text-gray-500">Pick visually distinct colors only</span>
                                    </div>
                                </div>
                            </div>
                        )}

                        {modalConfig.type === 'imageImportOption' && (
                            <div className="flex flex-col gap-3">
                                <button onClick={() => processImageImport('new', modalConfig.data.img)} className="p-3 bg-space-900 hover:bg-space-700 border border-space-600 rounded text-left">
                                    <div className="font-bold text-tech-400">New Project</div>
                                    <div className="text-xs text-gray-400">Resize canvas to fit image</div>
                                </button>
                                <button onClick={() => processImageImport('current', modalConfig.data.img)} className="p-3 bg-space-900 hover:bg-space-700 border border-space-600 rounded text-left">
                                    <div className="font-bold text-white">Current Layer</div>
                                    <div className="text-xs text-gray-400">Stamp onto current canvas size</div>
                                </button>
                            </div>
                        )}

                        {modalConfig.type === 'confirm-resize' && (
                             <p className="text-gray-300">Are you sure? This will clear your current artwork.</p>
                        )}
                        {modalConfig.type === 'clear' && (
                             <p className="text-gray-300">Clear the current layer? This cannot be fully undone if history limit is reached.</p>
                        )}
                    </Modal>

                    {/* Tooltip */}
                    {tooltip && (
                        <div className="fixed z-50 bg-black/90 text-white text-xs px-2 py-1 rounded pointer-events-none border border-space-600"
                            style={{ top: tooltip.top, left: tooltip.left }}>
                            {tooltip.text}
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<PixelArtStudio />);
    </script>
</body>
</html>